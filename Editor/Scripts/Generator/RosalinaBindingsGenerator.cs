using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;

internal class RosalinaBindingsGenerator
{
    private static readonly string GeneratedCodeHeader = @$"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Rosalina Code Generator tool.
//     Version: {RosalinaConstants.Version}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

";
    private const string DocumentFieldName = "_document";
    private const string DocumentRootVisualElementFieldName = "rootVisualElement";
    private const string RootVisualElementPropertyName = "Root";
    private const string RootVisualElementQueryMethodName = "Q";
    private const string InitializeDocumentMethodName = "InitializeDocument";
    private static readonly UsingDirectiveSyntax[] DefaultUsings = new UsingDirectiveSyntax[]
    {
        SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("UnityEngine")),
        SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("UnityEngine.UIElements"))
    };

    public RosalinaGenerationResult Generate(UIDocumentAsset document, string outputFileName)
    {
        if (document is null)
        {
            throw new ArgumentNullException(nameof(document), "Cannot generate binding with an empty UI document definition.");
        }

        if (string.IsNullOrEmpty(outputFileName))
        {
            throw new ArgumentException("An output file name is required.", nameof(outputFileName));
        }

        UxmlDocument uxmlDocument = RosalinaUXMLParser.ParseUIDocument(document.FullPath);

        MemberDeclarationSyntax documentVariable = CreateDocumentVariable();
        MemberDeclarationSyntax visualElementProperty = CreateVisualElementRootProperty();
        InitializationStatement[] statements = GenerateInitializeStatements(uxmlDocument);
        PropertyDeclarationSyntax[] propertyStatements = statements.Select(x => x.Property).ToArray();
        StatementSyntax[] initializationStatements = statements.Select(x => x.Statement).ToArray();

        MethodDeclarationSyntax initializeMethod = RosalinaSyntaxFactory.CreateMethod("void", InitializeDocumentMethodName, SyntaxKind.PublicKeyword)
            .WithBody(SyntaxFactory.Block(initializationStatements));

        MemberDeclarationSyntax[] classMembers = propertyStatements
            .Append(visualElementProperty)
            .Append(initializeMethod)
            .ToArray();

        ClassDeclarationSyntax @class = SyntaxFactory.ClassDeclaration(document.Name)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(documentVariable)
            .AddMembers(classMembers);

        CompilationUnitSyntax compilationUnit = SyntaxFactory.CompilationUnit()
            .AddUsings(DefaultUsings)
            .AddMembers(@class);

        string code = compilationUnit
            .NormalizeWhitespace()
            .ToFullString();
        string generatedCode = GeneratedCodeHeader + code;

        return new RosalinaGenerationResult(generatedCode, Path.Combine(document.Path, outputFileName));
    }

    private static MemberDeclarationSyntax CreateDocumentVariable()
    {
        string documentPropertyTypeName = typeof(UIDocument).Name;
        NameSyntax serializeFieldName = SyntaxFactory.ParseName(typeof(SerializeField).Name);

        FieldDeclarationSyntax documentField = RosalinaSyntaxFactory.CreateField(documentPropertyTypeName, DocumentFieldName, SyntaxKind.PrivateKeyword)
            .AddAttributeLists(
                SyntaxFactory.AttributeList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(serializeFieldName)
                    )
                )
            );

        return documentField;
    }

    private static MemberDeclarationSyntax CreateVisualElementRootProperty()
    {
        string propertyTypeName = typeof(VisualElement).Name;
        string documentFieldName = $"{DocumentFieldName}?";

        return RosalinaSyntaxFactory.CreateProperty(propertyTypeName, RootVisualElementPropertyName, SyntaxKind.PublicKeyword)
            .AddAccessorListAccessors(
                SyntaxFactory.AccessorDeclaration(
                    SyntaxKind.GetAccessorDeclaration,
                    SyntaxFactory.Block(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.Token(SyntaxKind.ReturnKeyword),
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.IdentifierName(documentFieldName),
                                SyntaxFactory.IdentifierName(DocumentRootVisualElementFieldName)),
                            SyntaxFactory.Token(SyntaxKind.SemicolonToken)
                        )
                    )
                )
            );
    }

    private static MemberAccessExpressionSyntax CreateRootQueryMethodAccessor()
    {
        return SyntaxFactory.MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            SyntaxFactory.IdentifierName($"{RootVisualElementPropertyName}?"),
            SyntaxFactory.Token(SyntaxKind.DotToken),
            SyntaxFactory.IdentifierName(RootVisualElementQueryMethodName)
        );
    }

    private static InitializationStatement[] GenerateInitializeStatements(UxmlDocument uxmlDocument)
    {
        var statements = new List<InitializationStatement>();
        MemberAccessExpressionSyntax documentQueryMethodAccess = CreateRootQueryMethodAccessor();
        IEnumerable<UxmlNode> childNodes = uxmlDocument.GetChildren();

        foreach (UxmlNode node in childNodes)
        {
            var uiProperty = new UIPropertyDescriptor(node.Type, node.Name);
            Type uiPropertyType = UIPropertyTypes.GetUIElementType(uiProperty.Type);

            if (uiPropertyType is null)
            {
                Debug.LogWarning($"[Rosalina]: Failed to get property type: '{uiProperty.Type}', field: '{uiProperty.Name}' for document '{uxmlDocument.Path}'. Property will be ignored.");
                continue;
            }

            PropertyDeclarationSyntax @property = RosalinaSyntaxFactory.CreateProperty(uiPropertyType.Name, uiProperty.Name, SyntaxKind.PublicKeyword)
                .AddAccessorListAccessors(
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
                )
                .AddAccessorListAccessors(
                    SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PrivateKeyword))
                        .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
                );

            var argumentList = SyntaxFactory.SeparatedList(new[]
            {
                SyntaxFactory.Argument(
                    SyntaxFactory.LiteralExpression(
                        SyntaxKind.StringLiteralExpression,
                        SyntaxFactory.Literal(uiProperty.Name)
                    )
                )
            });
            var cast = SyntaxFactory.CastExpression(
                SyntaxFactory.ParseTypeName(uiPropertyType.Name),
                SyntaxFactory.InvocationExpression(documentQueryMethodAccess, SyntaxFactory.ArgumentList(argumentList))
            );
            var statement = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName(uiProperty.Name),
                    cast
                )
            );

            statements.Add(new InitializationStatement(statement, property));
        }

        return statements.ToArray();
    }

    private struct InitializationStatement
    {
        public StatementSyntax Statement { get; }

        public PropertyDeclarationSyntax Property { get; }

        public InitializationStatement(StatementSyntax statement, PropertyDeclarationSyntax property)
        {
            Statement = statement;
            Property = property;
        }
    }
}
