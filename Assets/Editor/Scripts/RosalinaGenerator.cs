using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.UIElements;

internal static class RosalinaGenerator
{
    private static string GeneratedCodeHeader = @$"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Rosalina Code Generator tool.
//     Version: {RosalinaConstants.Version}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

";

    /// <summary>
    /// Generates the UI document code behind.
    /// </summary>
    /// <param name="uiDocumentPath">UI Document path.</param>
    public static void Generate(UIDocumentAsset document)
    {
        // Parse document
        UxmlNode uiDocumentRootNode = RosalinaUXMLParser.ParseUIDocument(document.FullPath);
        var namedNodes = uiDocumentRootNode.Children.FlattenTree(x => x.Children)
            .Where(x => x.HasName)
            .Select(x => new UIPropertyDescriptor(x.Type, x.Name))
            .ToList();

        // Start code generation.
        // 1. Create document variable
        // 2. Create VisualElementRoot
        // 3. Create variable and property for every nodes in the document
        // 4. Create the class
        // 5. Add required usings
        // 6. Build compilation unit
        // 7. Add class, usings and properties to compilation unit
        // 8. Generate code.

        var documentVariable = CreateDocumentVariable();
        var visualElementProperty = CreateVisualElementRootProperty();
        var initializeMethodStatements = new List<StatementSyntax>();
        var privateVariables = new List<MemberDeclarationSyntax>
        {
            documentVariable
        };
        var documentQueryMethodAccess = CreateRootQueryMethodAccessor();

        foreach (UIPropertyDescriptor property in namedNodes)
        {
            FieldDeclarationSyntax field = CreateField(property.Type, property.PrivateName, SyntaxKind.PrivateKeyword);

            privateVariables.Add(field);

            var argumentList = SyntaxFactory.SeparatedList(new[]
            { 
                SyntaxFactory.Argument(
                    SyntaxFactory.LiteralExpression(
                        SyntaxKind.StringLiteralExpression, 
                        SyntaxFactory.Literal(property.Name)
                    )
                )
            });
            var cast = SyntaxFactory.CastExpression(
                SyntaxFactory.ParseName(property.Type),
                SyntaxFactory.InvocationExpression(documentQueryMethodAccess, SyntaxFactory.ArgumentList(argumentList))
            );
            var assignment = SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    SyntaxFactory.IdentifierName(property.PrivateName),
                    cast
            );
            var statement = SyntaxFactory.ExpressionStatement(assignment);

            initializeMethodStatements.Add(statement);
        }

        var initializeMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), "InitializeDocument")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .WithBody(SyntaxFactory.Block(initializeMethodStatements));

        var members = new List<MemberDeclarationSyntax>(privateVariables)
        {
            visualElementProperty,
            initializeMethod
        };

        UsingDirectiveSyntax[] usings = GetDefaultUsingDirectives();
        ClassDeclarationSyntax @class = SyntaxFactory.ClassDeclaration(document.Name)
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddBaseListTypes(
                SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseName(typeof(MonoBehaviour).Name))
            )
            .AddMembers(members.ToArray());

        var compilationUnit = SyntaxFactory.CompilationUnit()
            .AddUsings(usings)
            .AddMembers(@class);

        string code = compilationUnit
            .NormalizeWhitespace()
            .ToFullString();
        string generatedCode = GeneratedCodeHeader + code;

        File.WriteAllText(document.GeneratedFileOutputPath, generatedCode);
    }

    private static UsingDirectiveSyntax[] GetDefaultUsingDirectives()
    {
        return new UsingDirectiveSyntax[]
        {
            SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("UnityEngine")),
            SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("UnityEngine.UIElements"))
        };
    }

    private static MemberDeclarationSyntax CreateDocumentVariable()
    {
        FieldDeclarationSyntax documentField = CreateField(typeof(UIDocument).Name, "_document", SyntaxKind.PrivateKeyword)
            .AddAttributeLists(
                SyntaxFactory.AttributeList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(SyntaxFactory.ParseName(typeof(SerializeField).Name))
                    )
                )
            );

        return documentField;
    }

    private static MemberDeclarationSyntax CreateVisualElementRootProperty()
    {
        return CreateProperty(typeof(VisualElement).Name, "Root", SyntaxKind.PublicKeyword)
            .AddAccessorListAccessors(
                SyntaxFactory.AccessorDeclaration(
                    SyntaxKind.GetAccessorDeclaration,
                    SyntaxFactory.Block(
                        SyntaxFactory.ReturnStatement(
                            SyntaxFactory.Token(SyntaxKind.ReturnKeyword),
                            SyntaxFactory.MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                SyntaxFactory.IdentifierName("_document?"),
                                SyntaxFactory.IdentifierName("rootVisualElement")),
                            SyntaxFactory.Token(SyntaxKind.SemicolonToken)
                        )
                    )
                )
            );
    }

    private static MemberAccessExpressionSyntax CreateRootQueryMethodAccessor()
    {
        return SyntaxFactory.MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            SyntaxFactory.IdentifierName("Root?"),
            SyntaxFactory.Token(SyntaxKind.DotToken),
            SyntaxFactory.IdentifierName("Q")
        );
    }

    private static FieldDeclarationSyntax CreateField(string fieldType, string fieldName, params SyntaxKind[] modifiers)
    {
        SyntaxToken[] fieldModifiers = modifiers.Select(x => SyntaxFactory.Token(x)).ToArray();
        NameSyntax variableTypeName = SyntaxFactory.ParseName(fieldType);
        VariableDeclarationSyntax variableSyntax = SyntaxFactory.VariableDeclaration(variableTypeName)
            .AddVariables(SyntaxFactory.VariableDeclarator(fieldName));

        return SyntaxFactory.FieldDeclaration(variableSyntax)
            .AddModifiers(fieldModifiers);
    }

    private static PropertyDeclarationSyntax CreateProperty(string propertyType, string propertyName, params SyntaxKind[] modifiers)
    {
        SyntaxToken[] propertyModifiers = modifiers.Select(x => SyntaxFactory.Token(x)).ToArray();
        NameSyntax propertyTypeName = SyntaxFactory.ParseName(propertyType);
        PropertyDeclarationSyntax property = SyntaxFactory.PropertyDeclaration(propertyTypeName, propertyName)
            .AddModifiers(propertyModifiers);

        return property;
    }

    private static IEnumerable<TValue> FlattenTree<TValue>(this IEnumerable<TValue> source, Func<TValue, IEnumerable<TValue>> selector)
    {
        return source.SelectMany(x => selector(x).FlattenTree(selector)).Concat(source);
    }
}
